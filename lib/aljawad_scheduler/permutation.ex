defmodule AljawadScheduler.Permutation do
  @moduledoc """
  Calculate and generate all possible combination of ordering elements in a list
  """
  @doc """
  Removes an element from a list by index
  """
  @spec remove_element(List.t(), integer()) :: {List.t(), any()}
  def remove_element([a], 0) do
    {[], a}
  end

  def remove_element([a | rest], 0) do
    {rest, a}
  end

  def remove_element(array, index) do
    {List.delete_at(array, index), Enum.at(array, index)}
  end

  @doc """
  Creates a order combination from a list by passing the array as the first
  argument and the second one as number of the combination.
  """
  @spec create_permutation(List.t()) :: List.t()
  def create_permutation([]), do: []
  def create_permutation(array), do: create_permutation(array, 0)

  @spec create_permutation(List.t(), integer()) :: List.t()
  def create_permutation([], _), do: []

  def create_permutation(array, index) do
    multiplier = multiplier(array)
    digit = digit(index, multiplier)
    {new_array, element} = remove_element(array, digit)
    normalize([element] ++ create_permutation(new_array, rem(index, multiplier)))
  end

  @doc """
  returns a number that represent the number of possibilities can be generated by keeping the first element in same index
  """
  @spec multiplier(List.t()) :: integer()
  def multiplier([]), do: 1
  def multiplier([_]), do: 1
  def multiplier(array) when is_list(array), do: factorial(Enum.count(array) - 1)
  def multiplier(range), do: multiplier(Enum.to_list(range))

  @doc """
  Converts a number to an index of the element in the array that should be
  selected
  """
  @spec digit(integer(), integer()) :: integer()
  def digit(int, multiplier), do: div(int, multiplier)

  @doc """
  Generate a factorial of a number
  """
  @spec factorial(integer()) :: integer()
  def factorial(0), do: 1
  def factorial(1), do: 1
  def factorial(number), do: number * factorial(number - 1)

  @doc """
  Remove the first element in the array if it was nil. This happens when the
  index of the permutation passed is grater than the number of possibilities
  where it will cycle again but will start with nils at the beginning.
  """
  @spec normalize(List.t()) :: List.t()
  def normalize([nil | rest]), do: rest
  def normalize(array), do: array
end
