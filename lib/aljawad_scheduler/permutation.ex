defmodule AljawadScheduler.Permutation do
  @moduledoc """
  Calculate and generate all possible combination of ordering elements in a list
  """
  @doc """
  Removes an element from a list by index
  """
  @spec remove_element(List.t(), integer()) :: {List.t(), any()}
  def remove_element([a], 0) do
    {[], a}
  end

  def remove_element([a | rest], 0) do
    {rest, a}
  end

  def remove_element(array, index) do
    {List.delete_at(array, index), Enum.at(array, index)}
  end

  @doc """
  Creates a order combination from a list by passing the array as the first
  argument and the second one as number of the combination.
  """
  @spec create_permutation(List.t()) :: List.t()
  def create_permutation([]), do: []
  def create_permutation(array), do: create_permutation(array, 0)

  @spec create_permutation(List.t(), integer()) :: List.t()
  def create_permutation([], _), do: []

  def create_permutation(array, index) do
    multiplier = multiplier(array)
    digit = digit(index, multiplier)
    {new_array, element} = remove_element(array, digit)
    normalize([element] ++ create_permutation(new_array, rem(index, multiplier)))
  end

  @doc """
  returns a number that represent the number of possibilities can be generated by keeping the first element in same index
  """
  @spec multiplier(List.t()) :: integer()
  def multiplier([]), do: 1
  def multiplier([_]), do: 1
  def multiplier(array) when is_list(array), do: factorial(Enum.count(array) - 1)
  def multiplier(range), do: multiplier(Enum.to_list(range))

  @doc """
  Converts a number to an index of the element in the array that should be
  selected
  """
  @spec digit(integer(), integer()) :: integer()
  def digit(int, multiplier), do: div(int, multiplier)

  @doc """
  Generate a factorial of a number
  """
  @spec factorial(integer()) :: integer()
  def factorial(0), do: 1
  def factorial(1), do: 1
  def factorial(number), do: number * factorial(number - 1)

  @doc """
  Remove the first element in the array if it was nil. This happens when the
  index of the permutation passed is grater than the number of possibilities
  where it will cycle again but will start with nils at the beginning.
  """
  @spec normalize(List.t()) :: List.t()
  def normalize([nil | rest]), do: rest
  def normalize(array), do: array

  @doc """
  checks if the number is a factorial. if so will generate range from `0` to the `factorial - 1` otherwise will respond with `:not_valid`
  """
  @spec to_range(number) :: {:ok, Range.t()} | {:error, :not_valid}
  def to_range(number) when is_integer(number) do
    case reduce(number) do
      :not_valid -> {:error, :not_valid}
      _base -> {:ok, 0..(number - 1)}
    end
  end

  @doc """
  Expand a range into sub ranges with size of the permutation of the previous
  factorial
  """
  def expand(first..last), do: expand(first..last, 1)

  def expand(first.._last, _levels) when first < 0 do
    {:error, :not_valid}
  end

  def expand(first..last, _levels) when first > last do
    {:error, :not_valid}
  end

  def expand(first..last, _levels) when first == last do
    {:ok, [first..last]}
  end

  def expand(first..last, levels) when first < last do
    # get the size of the range
    # get the base of the factorial and use the one previous to it
    # get number of ranges that can be generated

    if valid?(first..last) do
      size = last - first + 1
      base = reduce(size)
      width = factorial(max(base - levels, 1))

      Stream.cycle(1..2)
      |> Enum.reduce_while({[], first}, fn _, {ranges, current} ->
        from = current
        to = current + width - 1
        ranges = [ranges | [from..to]] |> List.flatten()
        result = {ranges, to + 1}
        if to >= last, do: {:halt, result}, else: {:cont, result}
      end)
      |> (fn {ranges, _} -> {:ok, ranges} end).()
    else
      {:error, :not_valid}
    end
  end

  def base(first..last, size) do
    if valid?(first..last) do
      case reduce(last - first + 1) do
        :not_valid ->
          {:error, :not_valid}

        base ->
          if base > size, do: {:error, :not_valid}, else: {:ok, base}
      end
    else
      {:error, :not_valid}
    end
  end

  @doc """
  Check if the range size is equals to a factorial
  """
  @spec valid?(Range.t()) :: boolean()
  def valid?(first..last) when first == last, do: true
  def valid?(first..last) when first + 1 == last, do: true
  def valid?(first..last) when last < first, do: false

  def valid?(first..last) when first < last do
    size = last - first + 1

    reduce(size, 2) != :not_valid
  end

  def valid?(_), do: false

  defp reduce(size, base \\ 2) do
    cond do
      size < 1 ->
        :not_valid

      size == 1 ->
        base - 1

      true ->
        reduce(
          div(size, base),
          base + 1
        )
    end
  end
end
